<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Club Path Visualization Test</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 20px; 
            background: #f5f5f5;
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            background: white; 
            padding: 20px; 
            border-radius: 8px; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-section { 
            margin: 20px 0; 
            padding: 20px; 
            border: 1px solid #ddd; 
            border-radius: 8px;
            background: #fafafa;
        }
        .button { 
            padding: 12px 24px; 
            margin: 8px; 
            background: #007bff; 
            color: white; 
            border: none; 
            border-radius: 4px; 
            cursor: pointer; 
            font-size: 14px;
        }
        .button:hover { background: #0056b3; }
        .button:disabled { background: #ccc; cursor: not-allowed; }
        .button.success { background: #28a745; }
        .button.warning { background: #ffc107; color: #000; }
        .button.danger { background: #dc3545; }
        
        .video-container {
            position: relative;
            margin: 20px 0;
            border: 2px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
        }
        
        video {
            width: 100%;
            height: auto;
            display: block;
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-weight: bold;
        }
        .status.success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status.error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .status.info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        
        .debug-panel {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .phase-indicator {
            display: flex;
            gap: 5px;
            margin: 10px 0;
        }
        .phase {
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            color: white;
        }
        .phase.address { background: #00FF00; }
        .phase.backswing { background: #FFFF00; color: #000; }
        .phase.downswing { background: #FF0000; }
        .phase.impact { background: #FF00FF; }
        .phase.follow-through { background: #0000FF; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéØ Club Path Visualization Test</h1>
        
        <!-- Test Video Selection -->
        <div class="test-section">
            <h2>üìπ Test Video Selection</h2>
            <div class="controls">
                <button class="button" onclick="loadTestVideo('tiger-woods-swing.mp4')">Tiger Woods Swing</button>
                <button class="button" onclick="loadTestVideo('tiger-woods-swing-slow.mp4')">Tiger Woods (Slow)</button>
                <button class="button" onclick="loadTestVideo('ludvig_aberg_driver.mp4')">Ludvig Aberg Driver</button>
                <button class="button" onclick="loadTestVideo('max_homa_iron.mp4')">Max Homa Iron</button>
                <input type="file" id="fileInput" accept="video/*" style="display: none;" onchange="loadCustomVideo(this)">
                <button class="button" onclick="document.getElementById('fileInput').click()">üìÅ Upload Custom Video</button>
            </div>
            <div id="videoStatus" class="status info">No video loaded</div>
        </div>
        
        <!-- Video Player with Overlay -->
        <div class="test-section">
            <h2>üé¨ Video Player with Club Path Overlay</h2>
            <div class="video-container">
                <video id="testVideo" controls style="display: none;">
                    Your browser does not support the video tag.
                </video>
                <canvas id="overlayCanvas"></canvas>
                <div id="noVideoMessage" style="padding: 40px; text-align: center; color: #666;">
                    Select a test video above to see the club path visualization
                </div>
            </div>
            
            <div class="controls">
                <button class="button" id="playBtn" onclick="togglePlay()" disabled>‚ñ∂Ô∏è Play</button>
                <button class="button" onclick="resetVideo()">üîÑ Reset</button>
                <button class="button" onclick="toggleOverlay()">üëÅÔ∏è Toggle Overlay</button>
                <button class="button" onclick="cycleOverlayMode()">üîÑ Cycle Mode</button>
            </div>
            
            <div class="phase-indicator" id="phaseIndicator"></div>
        </div>
        
        <!-- Overlay Controls -->
        <div class="test-section">
            <h2>üéõÔ∏è Overlay Controls</h2>
            <div class="controls">
                <button class="button" onclick="setOverlayMode('clean')">Clean View</button>
                <button class="button" onclick="setOverlayMode('analysis')">Analysis View</button>
                <button class="button" onclick="setOverlayMode('technical')">Technical View</button>
            </div>
            <div class="controls">
                <button class="button" onclick="toggleFeature('swingPath')">Toggle Club Path</button>
                <button class="button" onclick="toggleFeature('keyPoints')">Toggle Key Markers</button>
                <button class="button" onclick="toggleFeature('swingPlane')">Toggle Swing Plane</button>
                <button class="button" onclick="toggleFeature('realtimeMarker')">Toggle Real-time Marker</button>
            </div>
            <div id="overlayStatus" class="status info">Overlay: Analysis Mode</div>
        </div>
        
        <!-- Debug Information -->
        <div class="test-section">
            <h2>üêõ Debug Information</h2>
            <div class="controls">
                <button class="button" onclick="runDiagnostics()">Run Diagnostics</button>
                <button class="button" onclick="clearDebugLog()">Clear Log</button>
                <button class="button" onclick="exportDebugData()">Export Data</button>
            </div>
            <div id="debugLog" class="debug-panel">
                <div>Debug log will appear here...</div>
            </div>
        </div>
        
        <!-- Test Results -->
        <div class="test-section">
            <h2>‚úÖ Test Results</h2>
            <div id="testResults">
                <div>Run tests to see results here...</div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let currentVideo = null;
        let currentCanvas = null;
        let currentCtx = null;
        let isPlaying = false;
        let overlayEnabled = true;
        let currentOverlayMode = 'analysis';
        let debugLog = [];
        
        // Mock pose data for testing
        let mockPoses = [];
        let mockPhases = [];
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            currentVideo = document.getElementById('testVideo');
            currentCanvas = document.getElementById('overlayCanvas');
            currentCtx = currentCanvas.getContext('2d');
            
            // Set up video event listeners
            currentVideo.addEventListener('loadedmetadata', onVideoLoaded);
            currentVideo.addEventListener('timeupdate', onTimeUpdate);
            currentVideo.addEventListener('play', () => { isPlaying = true; updatePlayButton(); });
            currentVideo.addEventListener('pause', () => { isPlaying = false; updatePlayButton(); });
            
            log('Club Path Test Page initialized');
        });
        
        // Video loading functions
        function loadTestVideo(filename) {
            const videoPath = `/fixtures/swings/${filename}`;
            currentVideo.src = videoPath;
            currentVideo.style.display = 'block';
            document.getElementById('noVideoMessage').style.display = 'none';
            log(`Loading test video: ${filename}`);
            updateVideoStatus(`Loading ${filename}...`);
        }
        
        function loadCustomVideo(input) {
            const file = input.files[0];
            if (file) {
                const url = URL.createObjectURL(file);
                currentVideo.src = url;
                currentVideo.style.display = 'block';
                document.getElementById('noVideoMessage').style.display = 'none';
                log(`Loading custom video: ${file.name}`);
                updateVideoStatus(`Loading ${file.name}...`);
            }
        }
        
        function onVideoLoaded() {
            const video = currentVideo;
            const canvas = currentCanvas;
            
            // Set canvas size to match video
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            
            // Generate mock pose data for testing
            generateMockPoseData();
            
            log(`Video loaded: ${video.videoWidth}x${video.videoHeight}, duration: ${video.duration.toFixed(2)}s`);
            updateVideoStatus(`Video loaded: ${video.videoWidth}x${video.videoHeight}`);
            updatePlayButton();
            
            // Draw initial overlay
            drawOverlay();
        }
        
        function onTimeUpdate() {
            if (overlayEnabled) {
                drawOverlay();
            }
            updatePhaseIndicator();
        }
        
        // Mock data generation
        function generateMockPoseData() {
            const video = currentVideo;
            const frameCount = Math.floor(video.duration * 30); // 30fps
            mockPoses = [];
            mockPhases = [];
            
            // Generate poses with realistic swing motion
            for (let i = 0; i < frameCount; i++) {
                const t = i / (frameCount - 1);
                const swingAngle = t * Math.PI;
                
                // Create realistic club head trajectory
                const clubHeadX = 0.3 + 0.4 * Math.sin(swingAngle);
                const clubHeadY = 0.7 - 0.6 * t + 0.1 * Math.sin(swingAngle * 2);
                
                // Generate 33 MediaPipe landmarks
                const landmarks = [];
                for (let j = 0; j < 33; j++) {
                    if (j === 15) { // Right wrist
                        landmarks.push({ x: clubHeadX, y: clubHeadY, z: 0, visibility: 0.9 });
                    } else if (j === 16) { // Left wrist
                        landmarks.push({ x: clubHeadX - 0.1, y: clubHeadY + 0.05, z: 0, visibility: 0.9 });
                    } else if (j === 11) { // Left shoulder
                        landmarks.push({ x: 0.6, y: 0.3, z: 0, visibility: 0.9 });
                    } else if (j === 12) { // Right shoulder
                        landmarks.push({ x: 0.4, y: 0.3, z: 0, visibility: 0.9 });
                    } else if (j === 23) { // Left hip
                        landmarks.push({ x: 0.55, y: 0.6, z: 0, visibility: 0.9 });
                    } else if (j === 24) { // Right hip
                        landmarks.push({ x: 0.45, y: 0.6, z: 0, visibility: 0.9 });
                    } else {
                        landmarks.push({ x: 0.5, y: 0.5, z: 0, visibility: 0.8 });
                    }
                }
                
                mockPoses.push({
                    landmarks: landmarks,
                    timestamp: i * 33.33 // 30fps
                });
            }
            
            // Generate swing phases
            const phaseData = [
                { name: 'address', startFrame: 0, endFrame: Math.floor(frameCount * 0.1), color: '#00FF00' },
                { name: 'backswing', startFrame: Math.floor(frameCount * 0.1), endFrame: Math.floor(frameCount * 0.4), color: '#FFFF00' },
                { name: 'top', startFrame: Math.floor(frameCount * 0.4), endFrame: Math.floor(frameCount * 0.45), color: '#FFA500' },
                { name: 'downswing', startFrame: Math.floor(frameCount * 0.45), endFrame: Math.floor(frameCount * 0.7), color: '#FF0000' },
                { name: 'impact', startFrame: Math.floor(frameCount * 0.7), endFrame: Math.floor(frameCount * 0.75), color: '#FF00FF' },
                { name: 'follow-through', startFrame: Math.floor(frameCount * 0.75), endFrame: frameCount - 1, color: '#0000FF' }
            ];
            
            mockPhases = phaseData.map(phase => ({
                ...phase,
                startTime: phase.startFrame * 33.33,
                endTime: phase.endFrame * 33.33,
                duration: (phase.endFrame - phase.startFrame) * 33.33,
                confidence: 0.85,
                grade: 'B+'
            }));
            
            log(`Generated ${mockPoses.length} poses and ${mockPhases.length} phases`);
        }
        
        // Overlay drawing functions
        function drawOverlay() {
            if (!currentCtx || !overlayEnabled) return;
            
            const canvas = currentCanvas;
            const ctx = currentCtx;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (currentOverlayMode === 'clean') return;
            
            // Draw club path with phase coloring
            if (currentOverlayMode === 'analysis' || currentOverlayMode === 'technical') {
                drawClubPath(ctx);
                drawKeyMarkers(ctx);
                drawSwingPlane(ctx);
                drawRealtimeMarker(ctx);
            }
            
            // Draw technical overlays
            if (currentOverlayMode === 'technical') {
                drawPoseSkeleton(ctx);
            }
        }
        
        function drawClubPath(ctx) {
            if (!mockPoses.length || !mockPhases.length) return;
            
            const canvas = ctx.canvas;
            const trajectory = mockPoses.map((pose, i) => {
                const clubHead = estimateClubHead(pose.landmarks);
                return { x: clubHead.x, y: clubHead.y, frame: i };
            });
            
            // Draw each phase segment
            const phaseColors = {
                address: '#00FF00',
                backswing: '#FFFF00',
                downswing: '#FF0000',
                impact: '#FF00FF',
                'follow-through': '#0000FF'
            };
            
            mockPhases.forEach(phase => {
                if (phase.name === 'top') return; // Skip top phase for path drawing
                
                const start = Math.max(0, Math.min(phase.startFrame, trajectory.length - 1));
                const end = Math.max(0, Math.min(phase.endFrame, trajectory.length - 1));
                
                if (end <= start) return;
                
                ctx.beginPath();
                ctx.strokeStyle = phaseColors[phase.name] || '#FFFFFF';
                ctx.lineWidth = 4;
                if (phase.name === 'address') ctx.setLineDash([5, 5]);
                else ctx.setLineDash([]);
                
                for (let i = start; i <= end; i++) {
                    const pt = trajectory[i];
                    const x = pt.x * canvas.width;
                    const y = pt.y * canvas.height;
                    if (i === start) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            });
            
            ctx.setLineDash([]);
        }
        
        function drawKeyMarkers(ctx) {
            if (!mockPoses.length || !mockPhases.length) return;
            
            const canvas = ctx.canvas;
            const trajectory = mockPoses.map((pose, i) => {
                const clubHead = estimateClubHead(pose.landmarks);
                return { x: clubHead.x, y: clubHead.y, frame: i };
            });
            
            const keyPoints = [
                { name: 'ADDRESS', phase: 'address', color: '#00FF00', size: 8 },
                { name: 'TOP', phase: 'top', color: '#FFFF00', size: 12 },
                { name: 'IMPACT', phase: 'impact', color: '#FF00FF', size: 15 },
                { name: 'FINISH', phase: 'follow-through', color: '#0000FF', size: 10 }
            ];
            
            keyPoints.forEach(kp => {
                const phase = mockPhases.find(p => p.name === kp.phase);
                if (!phase) return;
                
                const frameIdx = phase.name === 'top' 
                    ? Math.floor((phase.startFrame + phase.endFrame) / 2)
                    : phase.name === 'follow-through' ? phase.endFrame : phase.startFrame;
                
                const idx = Math.max(0, Math.min(frameIdx, trajectory.length - 1));
                const pt = trajectory[idx];
                const x = pt.x * canvas.width;
                const y = pt.y * canvas.height;
                
                // Draw marker
                ctx.beginPath();
                ctx.arc(x, y, kp.size, 0, Math.PI * 2);
                ctx.fillStyle = kp.color;
                ctx.fill();
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw label
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 18px Arial';
                ctx.fillText(kp.name, x + 20, y - 8);
            });
        }
        
        function drawSwingPlane(ctx) {
            if (!mockPoses.length || !mockPhases.length) return;
            
            const canvas = ctx.canvas;
            const trajectory = mockPoses.map((pose, i) => {
                const clubHead = estimateClubHead(pose.landmarks);
                return { x: clubHead.x, y: clubHead.y, frame: i };
            });
            
            const addressPhase = mockPhases.find(p => p.name === 'address');
            const topPhase = mockPhases.find(p => p.name === 'top');
            const impactPhase = mockPhases.find(p => p.name === 'impact');
            
            if (!addressPhase || !topPhase || !impactPhase) return;
            
            const startIdx = addressPhase.startFrame;
            const topIdx = Math.floor((topPhase.startFrame + topPhase.endFrame) / 2);
            const impactIdx = impactPhase.startFrame;
            
            const start = trajectory[Math.max(0, Math.min(startIdx, trajectory.length - 1))];
            const top = trajectory[Math.max(0, Math.min(topIdx, trajectory.length - 1))];
            const impact = trajectory[Math.max(0, Math.min(impactIdx, trajectory.length - 1))];
            
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255, 165, 0, 0.7)';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 3]);
            ctx.moveTo(start.x * canvas.width, start.y * canvas.height);
            ctx.lineTo(top.x * canvas.width, top.y * canvas.height);
            ctx.lineTo(impact.x * canvas.width, impact.y * canvas.height);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        function drawRealtimeMarker(ctx) {
            if (!mockPoses.length) return;
            
            const canvas = ctx.canvas;
            const currentTime = currentVideo.currentTime * 1000; // Convert to ms
            
            // Find closest pose
            let closestIdx = 0;
            let minDiff = Infinity;
            mockPoses.forEach((pose, i) => {
                const diff = Math.abs(pose.timestamp - currentTime);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestIdx = i;
                }
            });
            
            const pose = mockPoses[closestIdx];
            const clubHead = estimateClubHead(pose.landmarks);
            const x = clubHead.x * canvas.width;
            const y = clubHead.y * canvas.height;
            
            // Draw real-time marker
            ctx.beginPath();
            ctx.arc(x, y, 6, 0, Math.PI * 2);
            ctx.fillStyle = '#FFFFFF';
            ctx.fill();
            ctx.strokeStyle = '#111827';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        function drawPoseSkeleton(ctx) {
            if (!mockPoses.length) return;
            
            const canvas = ctx.canvas;
            const currentTime = currentVideo.currentTime * 1000;
            
            // Find closest pose
            let closestIdx = 0;
            let minDiff = Infinity;
            mockPoses.forEach((pose, i) => {
                const diff = Math.abs(pose.timestamp - currentTime);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestIdx = i;
                }
            });
            
            const pose = mockPoses[closestIdx];
            const landmarks = pose.landmarks;
            
            // Draw skeleton connections
            const connections = [
                [11, 12], // shoulders
                [11, 13], [13, 15], // left arm
                [12, 14], [14, 16], // right arm
                [23, 24], // hips
                [23, 25], [25, 27], // left leg
                [24, 26], [26, 28]  // right leg
            ];
            
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
            ctx.lineWidth = 2;
            
            connections.forEach(([a, b]) => {
                const pa = landmarks[a];
                const pb = landmarks[b];
                if (pa && pb && pa.visibility > 0.5 && pb.visibility > 0.5) {
                    ctx.beginPath();
                    ctx.moveTo(pa.x * canvas.width, pa.y * canvas.height);
                    ctx.lineTo(pb.x * canvas.width, pb.y * canvas.height);
                    ctx.stroke();
                }
            });
            
            // Draw landmarks
            landmarks.forEach((landmark, i) => {
                if (landmark.visibility > 0.5) {
                    ctx.beginPath();
                    ctx.arc(landmark.x * canvas.width, landmark.y * canvas.height, 3, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.9)';
                    ctx.fill();
                }
            });
        }
        
        function estimateClubHead(landmarks) {
            if (!landmarks) return { x: 0.5, y: 0.5 };
            
            const leftWrist = landmarks[15];
            const rightWrist = landmarks[16];
            const leftShoulder = landmarks[11];
            const rightShoulder = landmarks[12];
            
            if (!leftWrist || !rightWrist || !leftShoulder || !rightShoulder) {
                return { x: 0.5, y: 0.5 };
            }
            
            // Calculate grip center (where the hands hold the club)
            const gripCenter = {
                x: (leftWrist.x + rightWrist.x) / 2,
                y: (leftWrist.y + rightWrist.y) / 2
            };
            
            // Calculate shoulder center for reference
            const shoulderCenter = {
                x: (leftShoulder.x + rightShoulder.x) / 2,
                y: (leftShoulder.y + rightShoulder.y) / 2
            };
            
            // Calculate the direction from shoulders to grip (this is roughly the club direction)
            const clubDirection = {
                x: gripCenter.x - shoulderCenter.x,
                y: gripCenter.y - shoulderCenter.y
            };
            
            // Normalize the direction
            const directionLength = Math.sqrt(clubDirection.x * clubDirection.x + clubDirection.y * clubDirection.y);
            if (directionLength === 0) return { x: 0.5, y: 0.5 };
            
            const normalizedDirection = {
                x: clubDirection.x / directionLength,
                y: clubDirection.y / directionLength
            };
            
            // Calculate club length based on the distance from shoulders to grip
            // A typical golf club is about 2-3 times the distance from shoulders to hands
            const shoulderToGripDistance = directionLength;
            const clubLength = shoulderToGripDistance * 2.5; // Adjust this multiplier as needed
            
            // Calculate club head position by extending from grip in the club direction
            // The club head is typically below and slightly behind the grip during most of the swing
            const clubHeadOffset = {
                x: normalizedDirection.x * clubLength,
                y: normalizedDirection.y * clubLength + 0.1 // Club head is typically lower than grip
            };
            
            // Final club head position
            const clubHead = {
                x: gripCenter.x + clubHeadOffset.x,
                y: gripCenter.y + clubHeadOffset.y
            };
            
            // Apply bounds checking
            return {
                x: Math.max(0, Math.min(1, clubHead.x)),
                y: Math.max(0, Math.min(1, clubHead.y)),
                z: 0
            };
        }
        
        // Control functions
        function togglePlay() {
            if (currentVideo.paused) {
                currentVideo.play();
            } else {
                currentVideo.pause();
            }
        }
        
        function resetVideo() {
            currentVideo.currentTime = 0;
            drawOverlay();
        }
        
        function toggleOverlay() {
            overlayEnabled = !overlayEnabled;
            if (overlayEnabled) {
                drawOverlay();
            } else {
                currentCtx.clearRect(0, 0, currentCanvas.width, currentCanvas.height);
            }
            log(`Overlay ${overlayEnabled ? 'enabled' : 'disabled'}`);
        }
        
        function cycleOverlayMode() {
            const modes = ['clean', 'analysis', 'technical'];
            const currentIndex = modes.indexOf(currentOverlayMode);
            const nextIndex = (currentIndex + 1) % modes.length;
            setOverlayMode(modes[nextIndex]);
        }
        
        function setOverlayMode(mode) {
            currentOverlayMode = mode;
            updateOverlayStatus();
            drawOverlay();
            log(`Overlay mode changed to: ${mode}`);
        }
        
        function toggleFeature(feature) {
            log(`Feature toggle: ${feature} (not implemented in test page)`);
        }
        
        function updatePhaseIndicator() {
            if (!mockPhases.length) return;
            
            const currentTime = currentVideo.currentTime * 1000;
            const currentPhase = mockPhases.find(phase => 
                currentTime >= phase.startTime && currentTime <= phase.endTime
            );
            
            const indicator = document.getElementById('phaseIndicator');
            indicator.innerHTML = '';
            
            mockPhases.forEach(phase => {
                const div = document.createElement('div');
                div.className = `phase ${phase.name}`;
                div.textContent = phase.name.toUpperCase();
                if (currentPhase && currentPhase.name === phase.name) {
                    div.style.border = '2px solid white';
                    div.style.boxShadow = '0 0 10px rgba(255,255,255,0.5)';
                }
                indicator.appendChild(div);
            });
        }
        
        // Status update functions
        function updateVideoStatus(message) {
            document.getElementById('videoStatus').textContent = message;
            document.getElementById('videoStatus').className = 'status info';
        }
        
        function updatePlayButton() {
            const btn = document.getElementById('playBtn');
            btn.disabled = !currentVideo.src;
            btn.textContent = isPlaying ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play';
        }
        
        function updateOverlayStatus() {
            document.getElementById('overlayStatus').textContent = `Overlay: ${currentOverlayMode.charAt(0).toUpperCase() + currentOverlayMode.slice(1)} Mode`;
        }
        
        // Debug functions
        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            debugLog.push(`[${timestamp}] ${message}`);
            updateDebugDisplay();
            console.log(`[Club Path Test] ${message}`);
        }
        
        function updateDebugDisplay() {
            const debugPanel = document.getElementById('debugLog');
            debugPanel.innerHTML = debugLog.slice(-20).join('<br>');
            debugPanel.scrollTop = debugPanel.scrollHeight;
        }
        
        function clearDebugLog() {
            debugLog = [];
            updateDebugDisplay();
        }
        
        function runDiagnostics() {
            log('Running diagnostics...');
            
            const results = {
                video: {
                    loaded: !!currentVideo.src,
                    dimensions: currentVideo.videoWidth ? `${currentVideo.videoWidth}x${currentVideo.videoHeight}` : 'N/A',
                    duration: currentVideo.duration ? `${currentVideo.duration.toFixed(2)}s` : 'N/A'
                },
                poses: {
                    count: mockPoses.length,
                    hasLandmarks: mockPoses.length > 0 ? mockPoses[0].landmarks.length : 0
                },
                phases: {
                    count: mockPhases.length,
                    names: mockPhases.map(p => p.name)
                },
                canvas: {
                    dimensions: `${currentCanvas.width}x${currentCanvas.height}`,
                    context: !!currentCtx
                }
            };
            
            log('Diagnostics complete:');
            log(`Video: ${JSON.stringify(results.video)}`);
            log(`Poses: ${JSON.stringify(results.poses)}`);
            log(`Phases: ${JSON.stringify(results.phases)}`);
            log(`Canvas: ${JSON.stringify(results.canvas)}`);
            
            updateTestResults(results);
        }
        
        function updateTestResults(results) {
            const resultsDiv = document.getElementById('testResults');
            resultsDiv.innerHTML = `
                <div class="status success">‚úÖ Diagnostics Complete</div>
                <div><strong>Video:</strong> ${results.video.loaded ? '‚úÖ' : '‚ùå'} ${results.video.dimensions} (${results.video.duration})</div>
                <div><strong>Poses:</strong> ${results.poses.count} frames, ${results.poses.hasLandmarks} landmarks each</div>
                <div><strong>Phases:</strong> ${results.phases.count} phases (${results.phases.names.join(', ')})</div>
                <div><strong>Canvas:</strong> ${results.canvas.dimensions} ${results.canvas.context ? '‚úÖ' : '‚ùå'}</div>
            `;
        }
        
        function exportDebugData() {
            const data = {
                timestamp: new Date().toISOString(),
                video: {
                    src: currentVideo.src,
                    dimensions: `${currentVideo.videoWidth}x${currentVideo.videoHeight}`,
                    duration: currentVideo.duration
                },
                poses: mockPoses.length,
                phases: mockPhases.map(p => ({
                    name: p.name,
                    startFrame: p.startFrame,
                    endFrame: p.endFrame,
                    duration: p.duration
                })),
                debugLog: debugLog
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `club-path-test-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            log('Debug data exported');
        }
    </script>
</body>
</html>
