<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tiger Woods Swing Analysis Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            color: white;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .video-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin: 20px auto;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
        }
        video {
            width: 100%;
            height: auto;
            display: block;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .controls {
            text-align: center;
            margin: 20px 0;
        }
        .controls button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        .controls button:hover {
            background: #45a049;
        }
        .controls input[type="file"] {
            margin: 10px;
            padding: 10px;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 5px;
        }
        .controls select {
            margin: 10px;
            padding: 8px;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 5px;
            font-size: 14px;
        }
        .controls label {
            margin: 10px;
            color: #ccc;
            font-size: 14px;
        }
        .info-panel {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .status.success { background: #4CAF50; }
        .status.warning { background: #FF9800; }
        .status.error { background: #F44336; }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .metric-card {
            background: #333;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
        }
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #4CAF50;
        }
        .metric-label {
            font-size: 14px;
            color: #ccc;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üèåÔ∏è Tiger Woods Swing Analysis Test</h1>
        <p>Test the improved club head tracer and weight distribution analysis with your Tiger Woods video.</p>
        
        <div class="controls">
            <input type="file" id="videoInput" accept="video/*" />
            <button onclick="startAnalysis()">Start Analysis</button>
            <button onclick="toggleOverlay()">Toggle Overlay</button>
            <button onclick="resetAnalysis()">Reset</button>
            <br>
            <label for="speedControl">Playback Speed:</label>
            <select id="speedControl" onchange="changePlaybackSpeed()">
                <option value="0.25">0.25x (Very Slow)</option>
                <option value="0.5">0.5x (Slow)</option>
                <option value="1.0" selected>1.0x (Normal)</option>
                <option value="1.5">1.5x (Fast)</option>
                <option value="2.0">2.0x (Very Fast)</option>
            </select>
        </div>

        <div class="video-container">
            <video id="video" controls>
                <source src="public/fixtures/swings/tiger-woods-swing.mp4" type="video/mp4">
                Your browser does not support the video tag.
            </video>
            <canvas id="overlay"></canvas>
        </div>

        <div class="info-panel">
            <h3>Analysis Status</h3>
            <div id="status" class="status warning">Ready to analyze video...</div>
            
            <div class="metrics">
                <div class="metric-card">
                    <div class="metric-value" id="clubHeadConfidence">0%</div>
                    <div class="metric-label">Club Head Confidence</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="weightLeft">50%</div>
                    <div class="metric-label">Left Foot Weight</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="weightRight">50%</div>
                    <div class="metric-label">Right Foot Weight</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="swingPhase">Address</div>
                    <div class="metric-label">Swing Phase</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Improved Club Head Tracer
        class TigerWoodsClubHeadTracer {
            constructor() {
                this.trajectory = [];
                this.config = {
                    minConfidence: 0.3,
                    smoothingFactor: 0.15,
                    clubLengthMultiplier: 2.5
                };
            }

            detectClubHeadPosition(landmarks, frameIndex, timestamp) {
                if (!landmarks || landmarks.length < 33) return null;

                const rightWrist = landmarks[16];
                const leftWrist = landmarks[15];
                const rightElbow = landmarks[14];
                const leftElbow = landmarks[13];
                const rightShoulder = landmarks[12];
                const leftShoulder = landmarks[11];

                if (!rightWrist || !leftWrist || !rightElbow || !leftElbow) return null;

                // Use multiple methods for accuracy
                const methods = this.calculateClubHeadMethods(landmarks, frameIndex);
                const weights = this.calculateMethodWeights(methods, frameIndex);
                
                let finalPosition = { x: 0.5, y: 0.5, z: 0.5 };
                let totalWeight = 0;
                let handedness = 'right';
                let clubLength = 0.3;
                let confidence = 0;

                for (let i = 0; i < methods.length; i++) {
                    const method = methods[i];
                    const weight = weights[i];
                    
                    finalPosition.x += method.position.x * weight;
                    finalPosition.y += method.position.y * weight;
                    finalPosition.z += method.position.z * weight;
                    handedness = method.handedness;
                    clubLength += method.clubLength * weight;
                    confidence += method.confidence * weight;
                    totalWeight += weight;
                }

                if (totalWeight > 0) {
                    finalPosition.x /= totalWeight;
                    finalPosition.y /= totalWeight;
                    finalPosition.z /= totalWeight;
                    clubLength /= totalWeight;
                    confidence /= totalWeight;
                }

                return {
                    x: Math.max(0, Math.min(1, finalPosition.x)),
                    y: Math.max(0, Math.min(1, finalPosition.y)),
                    z: Math.max(0, Math.min(1, finalPosition.z)),
                    confidence,
                    frame: frameIndex,
                    timestamp,
                    handedness,
                    clubLength,
                    swingPhase: this.determineSwingPhase(frameIndex)
                };
            }

            calculateClubHeadMethods(landmarks, frameIndex) {
                const methods = [];
                const rightWrist = landmarks[16];
                const leftWrist = landmarks[15];
                const rightElbow = landmarks[14];
                const leftElbow = landmarks[13];
                const rightShoulder = landmarks[12];
                const leftShoulder = landmarks[11];

                const isRightHanded = this.determineHandedness(landmarks);
                const dominantWrist = isRightHanded ? rightWrist : leftWrist;
                const dominantElbow = isRightHanded ? rightElbow : leftElbow;
                const dominantShoulder = isRightHanded ? rightShoulder : leftShoulder;

                // Method 1: Arm extension
                const armVector = {
                    x: dominantWrist.x - dominantElbow.x,
                    y: dominantWrist.y - dominantElbow.y
                };
                const armLength = Math.sqrt(armVector.x * armVector.x + armVector.y * armVector.y);
                const armAngle = Math.atan2(armVector.y, armVector.x);
                const clubLength1 = armLength * 2.2;
                const clubAngle1 = armAngle + (isRightHanded ? Math.PI / 3 : -Math.PI / 3);
                
                methods.push({
                    position: {
                        x: dominantWrist.x + Math.cos(clubAngle1) * clubLength1,
                        y: dominantWrist.y + Math.sin(clubAngle1) * clubLength1 + 0.08,
                        z: 0.5
                    },
                    handedness: isRightHanded ? 'right' : 'left',
                    clubLength: clubLength1,
                    confidence: Math.min(dominantWrist.visibility || 1, dominantElbow.visibility || 1) * 0.9,
                    method: 'arm_extension'
                });

                // Method 2: Shoulder-wrist line
                const shoulderWristVector = {
                    x: dominantWrist.x - dominantShoulder.x,
                    y: dominantWrist.y - dominantShoulder.y
                };
                const shoulderWristLength = Math.sqrt(shoulderWristVector.x * shoulderWristVector.x + shoulderWristVector.y * shoulderWristVector.y);
                const clubLength2 = shoulderWristLength * 1.8;
                const clubAngle2 = Math.atan2(shoulderWristVector.y, shoulderWristVector.x) + (isRightHanded ? Math.PI / 4 : -Math.PI / 4);
                
                methods.push({
                    position: {
                        x: dominantWrist.x + Math.cos(clubAngle2) * clubLength2,
                        y: dominantWrist.y + Math.sin(clubAngle2) * clubLength2 + 0.06,
                        z: 0.5
                    },
                    handedness: isRightHanded ? 'right' : 'left',
                    clubLength: clubLength2,
                    confidence: Math.min(dominantWrist.visibility || 1, dominantShoulder.visibility || 1) * 0.8,
                    method: 'shoulder_wrist'
                });

                return methods;
            }

            calculateMethodWeights(methods, frameIndex) {
                const weights = methods.map(method => method.confidence);
                const phase = this.determineSwingPhase(frameIndex);
                
                switch (phase) {
                    case 'address':
                        weights[0] *= 1.5;
                        weights[1] *= 1.2;
                        break;
                    case 'backswing':
                        weights[0] *= 1.2;
                        weights[1] *= 1.5;
                        break;
                    case 'top':
                        weights[0] *= 1.1;
                        weights[1] *= 1.3;
                        break;
                    case 'downswing':
                        weights[0] *= 1.5;
                        weights[1] *= 1.2;
                        break;
                    case 'impact':
                        weights.forEach((weight, index) => weights[index] = weight * 1.2);
                        break;
                }

                const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
                return totalWeight > 0 ? weights.map(weight => weight / totalWeight) : weights.map(() => 1 / weights.length);
            }

            determineHandedness(landmarks) {
                const rightWrist = landmarks[16];
                const leftWrist = landmarks[15];
                const rightElbow = landmarks[14];
                const leftElbow = landmarks[13];

                const rightArmLength = Math.sqrt(
                    Math.pow(rightWrist.x - rightElbow.x, 2) + 
                    Math.pow(rightWrist.y - rightElbow.y, 2)
                );
                const leftArmLength = Math.sqrt(
                    Math.pow(leftWrist.x - leftElbow.x, 2) + 
                    Math.pow(leftWrist.y - leftElbow.y, 2)
                );

                return rightArmLength > leftArmLength;
            }

            determineSwingPhase(frameIndex) {
                // More accurate phase detection based on actual swing dynamics
                const progress = frameIndex / 100;
                
                // Address: 0-8% of swing
                if (progress < 0.08) return 'address';
                
                // Backswing: 8-35% of swing (longer backswing)
                if (progress < 0.35) return 'backswing';
                
                // Top: 35-40% of swing (brief pause at top)
                if (progress < 0.40) return 'top';
                
                // Downswing: 40-75% of swing (faster downswing)
                if (progress < 0.75) return 'downswing';
                
                // Impact: 75-85% of swing (critical impact zone)
                if (progress < 0.85) return 'impact';
                
                // Follow-through: 85-100% of swing
                return 'follow-through';
            }
        }

        // Improved Weight Distribution Analyzer
        class TigerWoodsWeightAnalyzer {
            analyzeWeightDistribution(landmarks, frameIndex, totalFrames) {
                if (!landmarks || landmarks.length < 33) {
                    return { leftFoot: 50, rightFoot: 50, confidence: 0 };
                }

                const methods = this.calculateWeightDistributionMethods(landmarks);
                const weights = this.calculateMethodWeights(methods);
                
                let leftFootWeight = 50;
                let rightFootWeight = 50;
                let totalWeight = 0;

                for (let i = 0; i < methods.length; i++) {
                    const methodWeight = weights[i];
                    leftFootWeight += methods[i].leftFoot * methodWeight;
                    rightFootWeight += methods[i].rightFoot * methodWeight;
                    totalWeight += methodWeight;
                }
                
                if (totalWeight > 0) {
                    leftFootWeight /= totalWeight;
                    rightFootWeight /= totalWeight;
                }

                return {
                    leftFoot: Math.max(0, Math.min(100, leftFootWeight)),
                    rightFoot: Math.max(0, Math.min(100, rightFootWeight)),
                    confidence: methods.reduce((sum, method) => sum + method.confidence, 0) / methods.length
                };
            }

            calculateWeightDistributionMethods(landmarks) {
                const methods = [];
                const leftAnkle = landmarks[27];
                const rightAnkle = landmarks[28];
                const leftHip = landmarks[23];
                const rightHip = landmarks[24];
                const leftShoulder = landmarks[11];
                const rightShoulder = landmarks[12];

                // Method 1: Ankle height with body tilt compensation
                const ankleHeightDiff = rightAnkle.y - leftAnkle.y;
                const bodyTilt = this.calculateBodyTilt(landmarks);
                const compensatedAnkleDiff = ankleHeightDiff - (bodyTilt * 0.1);
                
                methods.push({
                    leftFoot: 50 + compensatedAnkleDiff * 800,
                    rightFoot: 50 - compensatedAnkleDiff * 800,
                    confidence: Math.min(leftAnkle.visibility || 1, rightAnkle.visibility || 1) * 0.95
                });

                // Method 2: Hip position with rotation compensation
                const hipCenter = {
                    x: (leftHip.x + rightHip.x) / 2,
                    y: (leftHip.y + rightHip.y) / 2
                };
                const ankleCenter = {
                    x: (leftAnkle.x + rightAnkle.x) / 2,
                    y: (leftAnkle.y + rightAnkle.y) / 2
                };
                const hipToAnkleOffset = hipCenter.x - ankleCenter.x;
                const hipRotation = this.calculateHipRotation(landmarks);
                const compensatedHipOffset = hipToAnkleOffset - (hipRotation * 0.05);
                
                methods.push({
                    leftFoot: 50 - compensatedHipOffset * 1500,
                    rightFoot: 50 + compensatedHipOffset * 1500,
                    confidence: Math.min(leftHip.visibility || 1, rightHip.visibility || 1) * 0.9
                });

                return methods;
            }

            calculateMethodWeights(methods) {
                const weights = methods.map(method => method.confidence);
                const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
                return totalWeight > 0 ? weights.map(weight => weight / totalWeight) : weights.map(() => 1 / weights.length);
            }

            calculateBodyTilt(landmarks) {
                const leftShoulder = landmarks[11];
                const rightShoulder = landmarks[12];
                const leftHip = landmarks[23];
                const rightHip = landmarks[24];
                
                if (!leftShoulder || !rightShoulder || !leftHip || !rightHip) return 0;
                
                const shoulderCenter = {
                    x: (leftShoulder.x + rightShoulder.x) / 2,
                    y: (leftShoulder.y + rightShoulder.y) / 2
                };
                const hipCenter = {
                    x: (leftHip.x + rightHip.x) / 2,
                    y: (leftHip.y + rightHip.y) / 2
                };
                
                const tilt = (shoulderCenter.x - hipCenter.x) * 2;
                return Math.max(-1, Math.min(1, tilt));
            }

            calculateHipRotation(landmarks) {
                const leftHip = landmarks[23];
                const rightHip = landmarks[24];
                const leftKnee = landmarks[25];
                const rightKnee = landmarks[26];
                
                if (!leftHip || !rightHip || !leftKnee || !rightKnee) return 0;
                
                const leftHipKneeAngle = Math.atan2(leftKnee.y - leftHip.y, leftKnee.x - leftHip.x);
                const rightHipKneeAngle = Math.atan2(rightKnee.y - rightHip.y, rightKnee.x - rightHip.x);
                
                const rotation = (leftHipKneeAngle - rightHipKneeAngle) * 0.5;
                return Math.max(-1, Math.min(1, rotation));
            }
        }

        // Test application
        let video, canvas, ctx;
        let clubHeadTracer, weightAnalyzer;
        let isAnalyzing = false;
        let showOverlay = true;
        let videoSpeedMultiplier = 1.0; // For speed compensation
        let detectedVideoSpeed = 1.0;
        let swingPhases = {}; // Store detected phases
        let clubHeadTrajectory = []; // Store full trajectory for analysis
        let phaseValidationResults = {}; // Store validation results

        function init() {
            video = document.getElementById('video');
            canvas = document.getElementById('overlay');
            ctx = canvas.getContext('2d');
            
            clubHeadTracer = new TigerWoodsClubHeadTracer();
            weightAnalyzer = new TigerWoodsWeightAnalyzer();

            // Set canvas size to match video
            video.addEventListener('loadedmetadata', () => {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                detectVideoSpeed();
            });

            // File input handler
            document.getElementById('videoInput').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const url = URL.createObjectURL(file);
                    video.src = url;
                    video.play();
                }
            });

            // Video speed change handler
            video.addEventListener('ratechange', () => {
                videoSpeedMultiplier = video.playbackRate;
                updateStatus(`Video speed: ${videoSpeedMultiplier}x (${videoSpeedMultiplier > 1 ? 'Fast' : videoSpeedMultiplier < 1 ? 'Slow' : 'Normal'})`, 'warning');
            });
        }

        function detectVideoSpeed() {
            // Detect if video is slow motion or fast motion
            // This is a heuristic - in real app, you'd analyze the actual video content
            const duration = video.duration;
            
            // Typical golf swing duration ranges:
            // Real-time: 1.5-3 seconds
            // Slow motion: 4-8 seconds
            // Very slow: 8+ seconds
            
            if (duration > 6) {
                detectedVideoSpeed = 0.5; // Slow motion
                videoSpeedMultiplier = 0.5;
                updateStatus(`Detected slow motion video (${duration.toFixed(1)}s) - Analysis adjusted`, 'warning');
            } else if (duration < 2) {
                detectedVideoSpeed = 2.0; // Fast motion
                videoSpeedMultiplier = 2.0;
                updateStatus(`Detected fast motion video (${duration.toFixed(1)}s) - Analysis adjusted`, 'warning');
            } else {
                detectedVideoSpeed = 1.0; // Normal speed
                videoSpeedMultiplier = 1.0;
                updateStatus(`Detected normal speed video (${duration.toFixed(1)}s)`, 'success');
            }
        }

        function startAnalysis() {
            if (!video.src) {
                updateStatus('Please select a video file first', 'error');
                return;
            }

            isAnalyzing = true;
            updateStatus('Analysis started - building trajectory and detecting phases...', 'warning');
            
            // Build complete trajectory first
            buildCompleteTrajectory();
            
            // Detect all phases
            detectAllSwingPhases();
            
            // Validate phases against video
            validatePhasesAgainstVideo();
            
            // Start real-time analysis
            video.addEventListener('timeupdate', analyzeFrame);
            
            updateStatus('Phase detection complete - real-time analysis active', 'success');
        }

        function buildCompleteTrajectory() {
            clubHeadTrajectory = [];
            const fps = 30;
            const totalFrames = Math.floor(video.duration * fps);
            
            console.log('üéØ Building complete club head trajectory...');
            
            for (let frame = 0; frame < totalFrames; frame++) {
                const time = frame / fps;
                const landmarks = generateSimulatedLandmarks(time, video.duration);
                
                if (landmarks) {
                    const clubHeadPosition = clubHeadTracer.detectClubHeadPosition(landmarks, frame, time * 1000);
                    if (clubHeadPosition) {
                        clubHeadTrajectory.push({
                            frame,
                            time,
                            position: clubHeadPosition,
                            landmarks
                        });
                    }
                }
            }
            
            console.log(`‚úÖ Trajectory built: ${clubHeadTrajectory.length} positions`);
        }

        function detectAllSwingPhases() {
            console.log('üéØ Detecting all swing phases...');
            
            // Detect impact first (most critical)
            const impactFrame = detectImpactPrecisely();
            console.log(`Impact detected at frame: ${impactFrame}`);
            
            // Detect other phases based on impact
            swingPhases = {
                address: detectAddressPhase(impactFrame),
                backswing: detectBackswingPhase(impactFrame),
                top: detectTopPhase(impactFrame),
                downswing: detectDownswingPhase(impactFrame),
                impact: { startFrame: impactFrame, endFrame: impactFrame + 5 },
                followThrough: detectFollowThroughPhase(impactFrame)
            };
            
            console.log('‚úÖ All phases detected:', swingPhases);
        }

        function detectImpactPrecisely() {
            if (clubHeadTrajectory.length < 10) return null;
            
            console.log('üéØ Detecting impact with multiple methods...');
            
            const detectionMethods = [
                detectImpactByClubSpeed(),
                detectImpactByWeightTransfer(),
                detectImpactByClubPosition(),
                detectImpactByTrajectoryAnalysis()
            ];
            
            // Filter valid detections
            const validDetections = detectionMethods
                .filter(frame => frame !== null && frame >= 0 && frame < clubHeadTrajectory.length)
                .sort((a, b) => a - b);
            
            if (validDetections.length === 0) {
                console.warn('No reliable impact detection - using fallback');
                return fallbackImpactDetection();
            }
            
            // Return median for robustness
            const impactFrame = validDetections[Math.floor(validDetections.length / 2)];
            console.log(`‚úÖ Impact detected at frame ${impactFrame} (${validDetections.length} methods agreed)`);
            return impactFrame;
        }

        function detectImpactByClubSpeed() {
            if (clubHeadTrajectory.length < 10) return null;
            
            // Calculate club head speeds
            const speeds = [];
            for (let i = 1; i < clubHeadTrajectory.length; i++) {
                const pos1 = clubHeadTrajectory[i-1].position;
                const pos2 = clubHeadTrajectory[i].position;
                const dx = pos2.x - pos1.x;
                const dy = pos2.y - pos1.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                speeds.push(distance);
            }
            
            // Find maximum acceleration (peak speed)
            let maxAcceleration = 0;
            let impactFrame = null;
            
            for (let i = 2; i < speeds.length - 1; i++) {
                const acceleration = speeds[i] - speeds[i-1];
                if (acceleration > maxAcceleration) {
                    maxAcceleration = acceleration;
                    impactFrame = i;
                }
            }
            
            console.log(`Club speed method: frame ${impactFrame}, acceleration: ${maxAcceleration.toFixed(4)}`);
            return impactFrame;
        }

        function detectImpactByWeightTransfer() {
            if (clubHeadTrajectory.length < 10) return null;
            
            // Find where weight transfer completes (right foot weight peaks)
            let maxRightWeight = 0;
            let impactFrame = null;
            
            for (let i = 0; i < clubHeadTrajectory.length; i++) {
                const landmarks = clubHeadTrajectory[i].landmarks;
                const weightDist = weightAnalyzer.analyzeWeightDistribution(landmarks, i, clubHeadTrajectory.length);
                
                if (weightDist.rightFoot > maxRightWeight) {
                    maxRightWeight = weightDist.rightFoot;
                    impactFrame = i;
                }
            }
            
            console.log(`Weight transfer method: frame ${impactFrame}, right weight: ${maxRightWeight.toFixed(1)}%`);
            return impactFrame;
        }

        function detectImpactByClubPosition() {
            if (clubHeadTrajectory.length < 10) return null;
            
            // Find where club head is lowest (closest to ground)
            let minY = 1;
            let impactFrame = null;
            
            for (let i = 0; i < clubHeadTrajectory.length; i++) {
                const y = clubHeadTrajectory[i].position.y;
                if (y < minY) {
                    minY = y;
                    impactFrame = i;
                }
            }
            
            console.log(`Club position method: frame ${impactFrame}, min Y: ${minY.toFixed(3)}`);
            return impactFrame;
        }

        function detectImpactByTrajectoryAnalysis() {
            if (clubHeadTrajectory.length < 10) return null;
            
            // Find where trajectory changes from downswing to follow-through
            let maxDownwardVelocity = 0;
            let impactFrame = null;
            
            for (let i = 1; i < clubHeadTrajectory.length; i++) {
                const pos1 = clubHeadTrajectory[i-1].position;
                const pos2 = clubHeadTrajectory[i].position;
                const downwardVelocity = pos2.y - pos1.y; // Positive = downward
                
                if (downwardVelocity > maxDownwardVelocity) {
                    maxDownwardVelocity = downwardVelocity;
                    impactFrame = i;
                }
            }
            
            console.log(`Trajectory method: frame ${impactFrame}, downward velocity: ${maxDownwardVelocity.toFixed(4)}`);
            return impactFrame;
        }

        function fallbackImpactDetection() {
            // Fallback: use 70% of trajectory length
            const fallbackFrame = Math.floor(clubHeadTrajectory.length * 0.7);
            console.log(`Fallback impact detection: frame ${fallbackFrame}`);
            return fallbackFrame;
        }

        function detectFollowThroughPhase(impactFrame) {
            if (!impactFrame || impactFrame >= clubHeadTrajectory.length - 10) {
                return { startFrame: impactFrame + 1, endFrame: clubHeadTrajectory.length - 1 };
            }
            
            console.log('üéØ Detecting follow-through completion...');
            
            // Method 1: Club deceleration after impact
            const followThroughFrame = detectFollowThroughByDeceleration(impactFrame);
            
            // Method 2: Body stabilization
            const bodyStabilizedFrame = detectFollowThroughByBodyStabilization(impactFrame);
            
            // Use the earlier of the two methods
            const endFrame = Math.min(followThroughFrame || clubHeadTrajectory.length - 1, 
                                    bodyStabilizedFrame || clubHeadTrajectory.length - 1);
            
            console.log(`‚úÖ Follow-through ends at frame ${endFrame}`);
            return { startFrame: impactFrame + 1, endFrame };
        }

        function detectFollowThroughByDeceleration(impactFrame) {
            const postImpactSpeeds = [];
            
            for (let i = impactFrame + 1; i < clubHeadTrajectory.length; i++) {
                const pos1 = clubHeadTrajectory[i-1].position;
                const pos2 = clubHeadTrajectory[i].position;
                const dx = pos2.x - pos1.x;
                const dy = pos2.y - pos1.y;
                const speed = Math.sqrt(dx * dx + dy * dy);
                postImpactSpeeds.push(speed);
            }
            
            // Find where speed drops below threshold
            const speedThreshold = 0.05;
            for (let i = 0; i < postImpactSpeeds.length; i++) {
                if (postImpactSpeeds[i] < speedThreshold) {
                    return impactFrame + i;
                }
            }
            
            return null;
        }

        function detectFollowThroughByBodyStabilization(impactFrame) {
            // Find where body position stabilizes (weight distribution returns to neutral)
            for (let i = impactFrame + 1; i < clubHeadTrajectory.length; i++) {
                const landmarks = clubHeadTrajectory[i].landmarks;
                const weightDist = weightAnalyzer.analyzeWeightDistribution(landmarks, i, clubHeadTrajectory.length);
                
                // Check if weight is returning to neutral (close to 50/50)
                const weightBalance = Math.abs(weightDist.leftFoot - weightDist.rightFoot);
                if (weightBalance < 10) { // Within 10% of balanced
                    return i;
                }
            }
            
            return null;
        }

        function detectAddressPhase(impactFrame) {
            const startFrame = 0;
            const endFrame = Math.floor(impactFrame * 0.1); // First 10% before impact
            return { startFrame, endFrame };
        }

        function detectBackswingPhase(impactFrame) {
            const startFrame = Math.floor(impactFrame * 0.1);
            const endFrame = Math.floor(impactFrame * 0.4);
            return { startFrame, endFrame };
        }

        function detectTopPhase(impactFrame) {
            const startFrame = Math.floor(impactFrame * 0.4);
            const endFrame = Math.floor(impactFrame * 0.5);
            return { startFrame, endFrame };
        }

        function detectDownswingPhase(impactFrame) {
            const startFrame = Math.floor(impactFrame * 0.5);
            const endFrame = impactFrame;
            return { startFrame, endFrame };
        }

        function validatePhasesAgainstVideo() {
            console.log('üéØ Validating phases against video content...');
            
            phaseValidationResults = {
                impact: validateImpactTiming(swingPhases.impact),
                followThrough: validateFollowThroughTiming(swingPhases.followThrough),
                overall: validateAllPhases(swingPhases)
            };
            
            console.log('‚úÖ Phase validation complete:', phaseValidationResults);
        }

        function validateImpactTiming(impactPhase) {
            const impactFrame = impactPhase.startFrame;
            const validationScore = 0.8; // Simulated - in real app would analyze video frames
            
            return {
                frame: impactFrame,
                score: validationScore,
                isValid: validationScore > 0.7,
                evidence: 'Club speed peak detected'
            };
        }

        function validateFollowThroughTiming(followThroughPhase) {
            const endFrame = followThroughPhase.endFrame;
            const validationScore = 0.75; // Simulated
            
            return {
                frame: endFrame,
                score: validationScore,
                isValid: validationScore > 0.7,
                evidence: 'Club deceleration detected'
            };
        }

        function validateAllPhases(phases) {
            const allValid = Object.values(phases).every(phase => 
                phase.startFrame >= 0 && phase.endFrame < clubHeadTrajectory.length
            );
            
            return {
                allPhasesValid: allValid,
                totalPhases: Object.keys(phases).length,
                validPhases: Object.keys(phases).filter(name => 
                    phases[name].startFrame >= 0 && phases[name].endFrame < clubHeadTrajectory.length
                ).length
            };
        }

        function analyzeFrame() {
            if (!isAnalyzing || !showOverlay) return;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Calculate current frame index
            const fps = 30;
            const frameIndex = Math.floor(video.currentTime * fps);
            
            // Get current phase using precise detection
            const currentPhase = getCurrentPhase(frameIndex);
            
            // Simulate pose landmarks (in real app, this would come from MediaPipe)
            const landmarks = generateSimulatedLandmarks(video.currentTime, video.duration);
            
            if (landmarks) {
                // Analyze club head position
                const clubHeadPosition = clubHeadTracer.detectClubHeadPosition(landmarks, frameIndex, video.currentTime * 1000);
                
                if (clubHeadPosition) {
                    // Use precise phase detection
                    clubHeadPosition.swingPhase = currentPhase.name;
                    clubHeadPosition.phaseAccuracy = currentPhase.accuracy;
                    
                    // Draw club head tracer with phase accuracy
                    drawClubHeadTracer(clubHeadPosition);
                    
                    // Draw phase boundaries
                    drawPhaseBoundaries();
                    
                    // Update metrics
                    document.getElementById('clubHeadConfidence').textContent = Math.round(clubHeadPosition.confidence * 100) + '%';
                    document.getElementById('swingPhase').textContent = `${currentPhase.name} (${Math.round(currentPhase.accuracy * 100)}%)`;
                }

                // Analyze weight distribution
                const weightDist = weightAnalyzer.analyzeWeightDistribution(landmarks, frameIndex, video.duration * fps);
                
                // Update weight metrics
                document.getElementById('weightLeft').textContent = Math.round(weightDist.leftFoot) + '%';
                document.getElementById('weightRight').textContent = Math.round(weightDist.rightFoot) + '%';

                // Draw weight distribution bars
                drawWeightDistribution(weightDist);
            }
        }

        function getCurrentPhase(frameIndex) {
            // Find which phase the current frame belongs to
            for (const [phaseName, phase] of Object.entries(swingPhases)) {
                if (frameIndex >= phase.startFrame && frameIndex <= phase.endFrame) {
                    // Calculate accuracy based on validation results
                    const validation = phaseValidationResults[phaseName] || { score: 0.8 };
                    return {
                        name: phaseName,
                        accuracy: validation.score,
                        isValid: validation.isValid,
                        frame: frameIndex,
                        phaseStart: phase.startFrame,
                        phaseEnd: phase.endFrame
                    };
                }
            }
            
            // Default fallback
            return {
                name: 'unknown',
                accuracy: 0.5,
                isValid: false,
                frame: frameIndex,
                phaseStart: 0,
                phaseEnd: 0
            };
        }

        function drawPhaseBoundaries() {
            if (!swingPhases || Object.keys(swingPhases).length === 0) return;
            
            const fps = 30;
            const currentTime = video.currentTime;
            const currentFrame = Math.floor(currentTime * fps);
            
            // Draw phase markers on timeline
            const timelineY = canvas.height - 30;
            const timelineHeight = 20;
            const timelineWidth = canvas.width - 40;
            const startX = 20;
            
            // Draw timeline background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(startX, timelineY, timelineWidth, timelineHeight);
            
            // Draw phase segments
            const totalFrames = Math.floor(video.duration * fps);
            Object.entries(swingPhases).forEach(([phaseName, phase], index) => {
                const phaseColors = {
                    address: '#4CAF50',
                    backswing: '#2196F3',
                    top: '#FF9800',
                    downswing: '#F44336',
                    impact: '#FF0000',
                    followThrough: '#9C27B0'
                };
                
                const color = phaseColors[phaseName] || '#666';
                const phaseStartX = startX + (phase.startFrame / totalFrames) * timelineWidth;
                const phaseEndX = startX + (phase.endFrame / totalFrames) * timelineWidth;
                const phaseWidth = phaseEndX - phaseStartX;
                
                // Draw phase segment
                ctx.fillStyle = color;
                ctx.fillRect(phaseStartX, timelineY, phaseWidth, timelineHeight);
                
                // Draw phase label
                ctx.fillStyle = '#FFFFFF';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(phaseName, phaseStartX + phaseWidth / 2, timelineY - 5);
            });
            
            // Draw current position indicator
            const currentX = startX + (currentFrame / totalFrames) * timelineWidth;
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(currentX - 1, timelineY - 5, 2, timelineHeight + 10);
        }

        function determineAccurateSwingPhase(currentTime, duration, speedMultiplier = 1.0) {
            // More accurate phase detection based on actual golf swing timing
            // Speed compensation adjusts the phase thresholds
            const progress = currentTime / duration;
            
            // Adjust phase thresholds based on video speed
            let addressThreshold = 0.05;
            let backswingThreshold = 0.30;
            let topThreshold = 0.35;
            let downswingThreshold = 0.70;
            let impactThreshold = 0.80;
            
            // Speed compensation: slower videos need different thresholds
            if (speedMultiplier < 1.0) {
                // Slow motion - phases happen more gradually
                addressThreshold = 0.08;
                backswingThreshold = 0.35;
                topThreshold = 0.40;
                downswingThreshold = 0.75;
                impactThreshold = 0.85;
            } else if (speedMultiplier > 1.0) {
                // Fast motion - phases happen more quickly
                addressThreshold = 0.03;
                backswingThreshold = 0.25;
                topThreshold = 0.30;
                downswingThreshold = 0.65;
                impactThreshold = 0.75;
            }
            
            // Address: 0-5% of swing (setup)
            if (progress < addressThreshold) return 'address';
            
            // Backswing: 5-30% of swing (takeaway to top)
            if (progress < backswingThreshold) return 'backswing';
            
            // Top: 30-35% of swing (brief transition)
            if (progress < topThreshold) return 'top';
            
            // Downswing: 35-70% of swing (transition to impact)
            if (progress < downswingThreshold) return 'downswing';
            
            // Impact: 70-80% of swing (critical impact zone - longer window)
            if (progress < impactThreshold) return 'impact';
            
            // Follow-through: 80-100% of swing
            return 'follow-through';
        }

        function generateSimulatedLandmarks(currentTime, duration) {
            // Simulate realistic golf swing landmarks based on time
            const progress = currentTime / duration;
            const landmarks = Array.from({ length: 33 }, (_, i) => ({
                x: Math.random(),
                y: Math.random(),
                z: Math.random(),
                visibility: Math.random() > 0.1 ? 0.9 : 0.1
            }));

            // More realistic swing simulation with proper phase transitions
            let wristX, wristY, elbowX, elbowY;
            let leftAnkleY, rightAnkleY;
            
            if (progress < 0.05) {
                // Address position
                wristX = 0.5;
                wristY = 0.4;
                elbowX = 0.5;
                elbowY = 0.5;
                leftAnkleY = 0.8;
                rightAnkleY = 0.8;
            } else if (progress < 0.30) {
                // Backswing - gradual movement up and back
                const backswingProgress = (progress - 0.05) / 0.25;
                wristX = 0.5 + Math.sin(backswingProgress * Math.PI) * 0.4;
                wristY = 0.4 - Math.sin(backswingProgress * Math.PI) * 0.3;
                elbowX = 0.5 + Math.sin(backswingProgress * Math.PI) * 0.2;
                elbowY = 0.5 - Math.sin(backswingProgress * Math.PI) * 0.2;
                leftAnkleY = 0.8 + Math.sin(backswingProgress * Math.PI) * 0.05;
                rightAnkleY = 0.8 - Math.sin(backswingProgress * Math.PI) * 0.05;
            } else if (progress < 0.35) {
                // Top of swing
                wristX = 0.9;
                wristY = 0.1;
                elbowX = 0.7;
                elbowY = 0.3;
                leftAnkleY = 0.85;
                rightAnkleY = 0.75;
            } else if (progress < 0.70) {
                // Downswing - rapid movement down and through
                const downswingProgress = (progress - 0.35) / 0.35;
                const downswingEase = 1 - Math.pow(1 - downswingProgress, 3); // Ease out curve
                wristX = 0.9 - downswingEase * 0.6;
                wristY = 0.1 + downswingEase * 0.5;
                elbowX = 0.7 - downswingEase * 0.3;
                elbowY = 0.3 + downswingEase * 0.3;
                leftAnkleY = 0.85 - downswingEase * 0.1;
                rightAnkleY = 0.75 + downswingEase * 0.1;
            } else if (progress < 0.80) {
                // Impact zone - critical moment
                wristX = 0.3;
                wristY = 0.6;
                elbowX = 0.4;
                elbowY = 0.6;
                leftAnkleY = 0.75;
                rightAnkleY = 0.85;
            } else {
                // Follow-through
                const followThroughProgress = (progress - 0.80) / 0.20;
                wristX = 0.3 - followThroughProgress * 0.3;
                wristY = 0.6 + followThroughProgress * 0.2;
                elbowX = 0.4 - followThroughProgress * 0.2;
                elbowY = 0.6 + followThroughProgress * 0.1;
                leftAnkleY = 0.75 + followThroughProgress * 0.05;
                rightAnkleY = 0.85 - followThroughProgress * 0.05;
            }
            
            // Ankles (weight distribution) - more realistic weight shift
            landmarks[27] = { x: 0.3, y: leftAnkleY, z: 0.5, visibility: 0.9 };
            landmarks[28] = { x: 0.7, y: rightAnkleY, z: 0.5, visibility: 0.9 };
            
            // Wrists (club head detection) - more realistic swing path
            landmarks[15] = { x: wristX - 0.1, y: wristY, z: 0.5, visibility: 0.9 };
            landmarks[16] = { x: wristX + 0.1, y: wristY, z: 0.5, visibility: 0.9 };
            
            // Elbows
            landmarks[13] = { x: elbowX - 0.1, y: elbowY, z: 0.5, visibility: 0.9 };
            landmarks[14] = { x: elbowX + 0.1, y: elbowY, z: 0.5, visibility: 0.9 };
            
            // Shoulders
            landmarks[11] = { x: 0.3, y: 0.2, z: 0.5, visibility: 0.9 };
            landmarks[12] = { x: 0.7, y: 0.2, z: 0.5, visibility: 0.9 };
            
            // Hips
            landmarks[23] = { x: 0.3, y: 0.4, z: 0.5, visibility: 0.9 };
            landmarks[24] = { x: 0.7, y: 0.4, z: 0.5, visibility: 0.9 };
            
            // Knees
            landmarks[25] = { x: 0.3, y: 0.6, z: 0.5, visibility: 0.9 };
            landmarks[26] = { x: 0.7, y: 0.6, z: 0.5, visibility: 0.9 };

            return landmarks;
        }

        function drawClubHeadTracer(position) {
            const x = position.x * canvas.width;
            const y = position.y * canvas.height;
            
            // Phase-specific styling
            const phaseColors = {
                address: { circle: 'rgba(76, 175, 80, 0.9)', stroke: '#4CAF50', highlight: 'rgba(76, 175, 80, 0.2)' },
                backswing: { circle: 'rgba(33, 150, 243, 0.9)', stroke: '#2196F3', highlight: 'rgba(33, 150, 243, 0.2)' },
                top: { circle: 'rgba(255, 152, 0, 0.9)', stroke: '#FF9800', highlight: 'rgba(255, 152, 0, 0.2)' },
                downswing: { circle: 'rgba(244, 67, 54, 0.9)', stroke: '#F44336', highlight: 'rgba(244, 67, 54, 0.2)' },
                impact: { circle: 'rgba(255, 0, 0, 0.9)', stroke: '#FF0000', highlight: 'rgba(255, 0, 0, 0.3)' },
                followThrough: { circle: 'rgba(156, 39, 176, 0.9)', stroke: '#9C27B0', highlight: 'rgba(156, 39, 176, 0.2)' }
            };
            
            const phaseStyle = phaseColors[position.swingPhase] || phaseColors.address;
            const isImpact = position.swingPhase === 'impact';
            const isFollowThrough = position.swingPhase === 'followThrough';
            
            // Adjust size based on phase
            let circleRadius = 12;
            if (isImpact) circleRadius = 18;
            else if (isFollowThrough) circleRadius = 15;
            
            // Draw phase highlight
            ctx.beginPath();
            ctx.arc(x, y, circleRadius + 8, 0, 2 * Math.PI);
            ctx.fillStyle = phaseStyle.highlight;
            ctx.fill();
            ctx.strokeStyle = phaseStyle.stroke;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw club head circle
            ctx.beginPath();
            ctx.arc(x, y, circleRadius, 0, 2 * Math.PI);
            ctx.fillStyle = phaseStyle.circle;
            ctx.fill();
            ctx.strokeStyle = phaseStyle.stroke;
            ctx.lineWidth = isImpact ? 4 : 3;
            ctx.stroke();
            
            // Draw club head info with phase accuracy
            ctx.fillStyle = phaseStyle.stroke;
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`Club Head (${position.handedness})`, x + 30, y - 15);
            ctx.font = '12px Arial';
            ctx.fillText(`Conf: ${Math.round(position.confidence * 100)}%`, x + 30, y);
            ctx.fillText(`Phase: ${position.swingPhase}`, x + 30, y + 15);
            
            // Show phase accuracy if available
            if (position.phaseAccuracy !== undefined) {
                const accuracyColor = position.phaseAccuracy > 0.8 ? '#00FF00' : position.phaseAccuracy > 0.6 ? '#FFAA00' : '#FF0000';
                ctx.fillStyle = accuracyColor;
                ctx.fillText(`Accuracy: ${Math.round(position.phaseAccuracy * 100)}%`, x + 30, y + 30);
            }
            
            // Phase-specific warnings
            if (isImpact) {
                ctx.fillStyle = '#FF0000';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('IMPACT ZONE!', canvas.width / 2, 35);
            } else if (isFollowThrough) {
                ctx.fillStyle = '#9C27B0';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('FOLLOW-THROUGH', canvas.width / 2, 35);
            }
        }

        function drawWeightDistribution(weightDist) {
            const barHeight = 20;
            const barWidth = 200;
            const startX = (canvas.width - barWidth) / 2;
            const startY = canvas.height - 50;
            
            // Left foot bar
            ctx.fillStyle = 'rgba(0, 255, 0, 0.7)';
            ctx.fillRect(startX, startY, (weightDist.leftFoot / 100) * barWidth, barHeight);
            
            // Right foot bar
            ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
            ctx.fillRect(startX + (weightDist.leftFoot / 100) * barWidth, startY, (weightDist.rightFoot / 100) * barWidth, barHeight);
            
            // Labels
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`L: ${Math.round(weightDist.leftFoot)}%`, startX + (weightDist.leftFoot / 100) * barWidth / 2, startY - 5);
            ctx.fillText(`R: ${Math.round(weightDist.rightFoot)}%`, startX + (weightDist.leftFoot / 100) * barWidth + (weightDist.rightFoot / 100) * barWidth / 2, startY - 5);
        }

        function toggleOverlay() {
            showOverlay = !showOverlay;
            if (!showOverlay) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        }

        function resetAnalysis() {
            isAnalyzing = false;
            showOverlay = true;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Reset all analysis data
            swingPhases = {};
            clubHeadTrajectory = [];
            phaseValidationResults = {};
            
            updateStatus('Analysis reset - ready to analyze video...', 'warning');
            
            // Reset metrics
            document.getElementById('clubHeadConfidence').textContent = '0%';
            document.getElementById('weightLeft').textContent = '50%';
            document.getElementById('weightRight').textContent = '50%';
            document.getElementById('swingPhase').textContent = 'Address';
            
            console.log('üîÑ Analysis reset - all data cleared');
        }

        function changePlaybackSpeed() {
            const speedControl = document.getElementById('speedControl');
            const newSpeed = parseFloat(speedControl.value);
            video.playbackRate = newSpeed;
            videoSpeedMultiplier = newSpeed;
            updateStatus(`Playback speed changed to ${newSpeed}x`, 'warning');
        }

        function updateStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
        }

        // Initialize when page loads
        window.onload = init;
    </script>
</body>
</html>
